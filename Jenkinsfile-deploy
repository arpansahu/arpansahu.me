pipeline {
    agent { label 'local' }
    parameters {
        booleanParam(name: 'skip_checks', defaultValue: false, description: 'Skip the Check for Changes stage')
        choice(name: 'DEPLOY_TYPE', choices: ['kubernetes', 'docker'], description: 'Select deployment type')
    }
    environment {
        REGISTRY = "harbor.arpansahu.me"
        REPOSITORY = "library/arpansahu_dot_me"
        IMAGE_TAG = "latest"  // or use a specific tag if needed
        KUBECONFIG = "${env.WORKSPACE}/kubeconfig"  // Set the KUBECONFIG environment variable
        NGINX_CONF = "/etc/nginx/sites-available/arpansahu-dot-me"
        ENV_PROJECT_NAME = "arpansahu_dot_me"
    }
    stages {
        stage('Initialize') {
            steps {
                script {
                    echo "Current workspace path is: ${env.WORKSPACE}"
                }
            }
        }
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        stage('Setup Kubernetes Config') {
            when {
                expression { return params.DEPLOY_TYPE == 'kubernetes' }
            }
            steps {
                script {
                    // Copy the kubeconfig file to the workspace
                    sh "sudo cp /root/.kube/config ${env.WORKSPACE}/kubeconfig"
                    // Change permissions of the kubeconfig file
                    sh "sudo chmod 644 ${env.WORKSPACE}/kubeconfig"
                }
            }
        }
        stage('Check for New Image') {
            when {
                expression { !params.skip_checks }
            }
            steps {
                script {
                    def currentTag = ''
                    def runningInDocker = sh(script: "docker ps -q -f name=${ENV_PROJECT_NAME}", returnStdout: true).trim()
                    if (runningInDocker) {
                        // Get the image tag of the currently running Docker container
                        echo "Docker is running, getting image tag from the current Docker container"
                        currentTag = sh(script: "docker inspect -f '{{.Config.Image}}' ${ENV_PROJECT_NAME} | awk -F':' '{print \$2}'", returnStdout: true).trim()
                        echo "Current Docker image tag: ${currentTag}"
                    } else {
                        sh 'kubectl get pods -l app=arpansahu-dot-me'
                        def podName = sh(script: "kubectl get pods -l app=arpansahu-dot-me -o=jsonpath='{.items[0].metadata.name}' || echo 'none'", returnStdout: true).trim()
                        if (podName != 'none') {
                            echo "Pod is running, getting image tag from the currently running pod"
                            // Get the image tag of the currently running Kubernetes pod
                            currentTag = sh(script: "kubectl get pod ${podName} -o=jsonpath='{.spec.containers[0].image}' | awk -F':' '{print \$2}'", returnStdout: true).trim()
                            echo "Current Kubernetes image tag: ${currentTag}"
                        } else {
                            currentTag = 'none'
                        }
                    }

                    if (currentTag == 'none') {
                        echo "No running instance found in Docker or Kubernetes."
                        currentBuild.description = 'No running instance found'
                        echo "Moving on with the Deployment..."
                    } else {
                        // Pull the latest image to get its tag
                        sh "docker pull ${REGISTRY}/${REPOSITORY}:${IMAGE_TAG}"
                        def latestTag = sh(script: "docker inspect -f '{{.Config.Labels.build}}' ${REGISTRY}/${REPOSITORY}:${IMAGE_TAG} || echo 'none'", returnStdout: true).trim()
                        echo "Latest image tag: ${latestTag}"

                        // Check if the tags are different
                        if (currentTag != latestTag) {
                            env.NEW_IMAGE_AVAILABLE = 'true'
                            echo "New image available, proceeding with deployment."
                        } else {
                            env.NEW_IMAGE_AVAILABLE = 'false'
                            echo "No new image available, skipping deployment."
                        }
                    }
                }
            }
        }
        stage('Deploy') {
            when {
                expression {
                    return params.skip_checks || env.NEW_IMAGE_AVAILABLE == 'true' ||  currentBuild.description == 'No running instance found'
                }
            }
            steps {
                script {
                    def currentTag = ''
                    def runningInDocker = sh(script: "docker ps -q -f name=${ENV_PROJECT_NAME}", returnStdout: true).trim()
                    if (runningInDocker) {
                        // Get the image tag of the currently running Docker container
                        echo "Docker is running, getting image tag from the current Docker container"
                        currentTag = sh(script: "docker inspect -f '{{.Config.Image}}' ${ENV_PROJECT_NAME} | awk -F':' '{print \$2}'", returnStdout: true).trim()
                        echo "Current Docker image tag: ${currentTag}"
                    } else {
                        def podName = sh(script: "kubectl get pods -l app=arpansahu-dot-me -o=jsonpath='{.items[0].metadata.name}' || echo 'none'", returnStdout: true).trim()
                        if (podName != 'none') {
                            echo "Pod is running, getting image tag from the currently running pod"
                            // Get the image tag of the currently running Kubernetes pod
                            currentTag = sh(script: "kubectl get pod ${podName} -o=jsonpath='{.spec.containers[0].image}' | awk -F':' '{print \$2}'", returnStdout: true).trim()
                            echo "Current Kubernetes image tag: ${currentTag}"
                        } else {
                            currentTag = 'none'
                        }
                    }

                    if (currentTag == 'none') {
                        echo "No running instance found in Docker or Kubernetes."
                        currentBuild.description = 'No running instance found'
                        echo "Moving on with the Deployment..."
                    } else {
                        // Pull the latest image to get its tag
                        sh "docker pull ${REGISTRY}/${REPOSITORY}:${IMAGE_TAG}"
                        def latestTag = sh(script: "docker inspect -f '{{.Config.Labels.build}}' ${REGISTRY}/${REPOSITORY}:${IMAGE_TAG} || echo 'none'", returnStdout: true).trim()
                        echo "Latest image tag: ${latestTag}"

                        // Check if the tags are different
                        if (currentTag != latestTag) {
                            env.NEW_IMAGE_AVAILABLE = 'true'
                            echo "New image available, proceeding with deployment."
                        } else {
                            env.NEW_IMAGE_AVAILABLE = 'false'
                            echo "No new image available, skipping deployment."
                        }
                    }
                }
            }
        }
    }
    post {
        success {
            script {
                // Retrieve the latest commit message
                def commitMessage = sh(script: "git log -1 --pretty=%B", returnStdout: true).trim()
                if (currentBuild.description == 'DEPLOYMENT_EXECUTED') {
                    sh """curl -s \
                    -X POST \
                    --user $MAIL_JET_API_KEY:$MAIL_JET_API_SECRET \
                    https://api.mailjet.com/v3.1/send \
                    -H "Content-Type:application/json" \
                    -d '{
                        "Messages":[
                                {
                                        "From": {
                                                "Email": "$MAIL_JET_EMAIL_ADDRESS",
                                                "Name": "ArpanSahuOne Jenkins Notification"
                                        },
                                        "To": [
                                                {
                                                        "Email": "$MY_EMAIL_ADDRESS",
                                                        "Name": "Development Team"
                                                }
                                        ],
                                        "Subject": "Jenkins Build Pipeline your project ${currentBuild.fullDisplayName} Ran Successfully",
                                        "TextPart": "Hola Development Team, your project ${currentBuild.fullDisplayName} is now deployed",
                                        "HTMLPart": "<h3>Hola Development Team, your project ${currentBuild.fullDisplayName} is now deployed </h3> <br> <p> Build Url: ${env.BUILD_URL}  </p>"
                                }
                        ]
                    }'"""
                }
                // Trigger the common_readme job on success if the commit message is not "Automatic Update readme.html for all repositories"
                if (commitMessage != "Automatic Update readme.html for all repositories") {
                    build job: 'common_readme', parameters: [string(name: 'project_git_url', value: 'https://github.com/arpansahu/${ENV_PROJECT_NAME}'), string(name: 'environment', value: 'prod')], wait: false
                } else {
                    echo "Skipping common_readme job trigger due to commit message: ${commitMessage}"
                }
            }
        }
        failure {
            sh """curl -s \
            -X POST \
            --user $MAIL_JET_API_KEY:$MAIL_JET_API_SECRET \
            https://api.mailjet.com/v3.1/send \
            -H "Content-Type:application/json" \
            -d '{
                "Messages":[
                        {
                                "From": {
                                        "Email": "$MAIL_JET_EMAIL_ADDRESS",
                                        "Name": "ArpanSahuOne Jenkins Notification"
                                },
                                "To": [
                                        {
                                                "Email": "$MY_EMAIL_ADDRESS",
                                                "Name": "Developer Team"
                                        }
                                ],
                            "Subject": "Jenkins Build Pipeline your project ${currentBuild.fullDisplayName} Ran Failed",
                            "TextPart": "Hola Development Team, your project ${currentBuild.fullDisplayName} deployment failed",
                            "HTMLPart": "<h3>Hola Development Team, your project ${currentBuild.fullDisplayName} is not deployed, Build Failed </h3> <br> <p> Build Url: ${env.BUILD_URL}  </p>"
                        }
                ]
            }'"""
        }
    }
}