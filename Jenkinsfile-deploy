pipeline {
    agent { label 'local' }
    parameters {
        booleanParam(name: 'skip_checks', defaultValue: false, description: 'Skip the Check for Changes stage')
        choice(name: 'DEPLOY_TYPE', choices: ['kubernetes', 'docker'], description: 'Select deployment type')
    }
    environment {
        REGISTRY = "harbor.arpansahu.me"
        REPOSITORY = "library/arpansahu_dot_me"
        IMAGE_TAG = "latest"  // or use a specific tag if needed
        KUBECONFIG = "${env.WORKSPACE}/kubeconfig"  // Set the KUBECONFIG environment variable
        NGINX_CONF = "/etc/nginx/sites-available/arpansahu-dot-me"
        ENV_PROJECT_NAME = "arpansahu_dot_me"
    }
    stages {
        stage('Initialize') {
            steps {
                script {
                    echo "Current workspace path is: ${env.WORKSPACE}"
                    writeFile file: 'get_image_digest.sh', text: '''#!/bin/bash
                    DOCKER_REGISTRY_USERNAME=$1
                    DOCKER_REGISTRY_PASSWORD=$2
                    REGISTRY=$3
                    REPOSITORY=$4
                    IMAGE_TAG=$5

                    digest=$(curl -s -u ${DOCKER_REGISTRY_USERNAME}:${DOCKER_REGISTRY_PASSWORD} https://${REGISTRY}/v2/${REPOSITORY}/manifests/${IMAGE_TAG} | jq -r '.config.digest')
                    echo $digest
                    '''
                    sh 'chmod +x get_image_digest.sh'
                }
            }
        }
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        stage('Setup Kubernetes Config') {
            when {
                expression { return params.DEPLOY_TYPE == 'kubernetes' }
            }
            steps {
                script {
                    // Copy the kubeconfig file to the workspace
                    sh "sudo cp /root/.kube/config ${env.WORKSPACE}/kubeconfig"
                    // Change permissions of the kubeconfig file
                    sh "sudo chmod 644 ${env.WORKSPACE}/kubeconfig"
                }
            }
        }
        stage('Check jq Installation') {
            steps {
                script {
                    def jqInstalled = sh(script: "command -v jq || echo 'not installed'", returnStdout: true).trim()
                    if (jqInstalled == 'not installed') {
                        error "'jq' is not installed. Please install 'jq' to proceed."
                    } else {
                        echo "'jq' is installed."
                    }
                }
            }
        }
        stage('Check for New Image') {
            when {
                expression { !params.skip_checks }
            }
            steps {
                script {
                    def currentDigest = ''
                    def runningInDocker = sh(script: "docker ps -q -f name=${ENV_PROJECT_NAME}", returnStdout: true).trim()
                    if (runningInDocker) {
                        // Get the digest of the currently running Docker container
                        echo "Docker is running, getting image digest from the current Docker container"
                        currentDigest = sh(script: "docker inspect --format='{{.RepoDigests}}' ${ENV_PROJECT_NAME} | grep -o 'sha256:[a-f0-9]*'", returnStdout: true).trim()
                        echo "Current Docker image digest: ${currentDigest}"
                    } else {
                        def podName = sh(script: "kubectl get pods -l app=arpansahu-dot-me -o=jsonpath='{.items[0].metadata.name}' || echo 'none'", returnStdout: true).trim()
                        if (podName != 'none') {
                            echo "Pod is running, getting image digest from the currently running pod"
                            // Get the digest of the currently running Kubernetes pod
                            currentDigest = sh(script: "kubectl get pod ${podName} -o=jsonpath='{.status.containerStatuses[0].imageID}' | grep -o 'sha256:[a-f0-9]*'", returnStdout: true).trim()
                            echo "Current Kubernetes image digest: ${currentDigest}"
                        } else {
                            currentDigest = 'none'
                        }
                    }

                    if (currentDigest == 'none') {
                        echo "No running instance found in Docker or Kubernetes."
                        currentBuild.description = 'No running instance found'
                        echo "Moving on with the Deployment..."
                    } else {
                        withCredentials([usernamePassword(credentialsId: 'harbor-credentials', passwordVariable: 'DOCKER_REGISTRY_PASSWORD', usernameVariable: 'DOCKER_REGISTRY_USERNAME')]) {
                            // Get the latest image digest from the Docker registry
                            def latestDigest = sh(script: '''
                                ./get_image_digest.sh "${DOCKER_REGISTRY_USERNAME}" "${DOCKER_REGISTRY_PASSWORD}" "${REGISTRY}" "${REPOSITORY}" "${IMAGE_TAG}"
                            ''', returnStdout: true).trim()
                            echo "Latest image digest: ${latestDigest}"

                            // Check if the digests are different
                            if (currentDigest != latestDigest) {
                                env.NEW_IMAGE_AVAILABLE = 'true'
                                echo "New image available, proceeding with deployment."
                            } else {
                                env.NEW_IMAGE_AVAILABLE = 'false'
                                echo "No new image available, skipping deployment."
                            }
                        }
                    }
                }
            }
        }
        stage('Deploy') {
            when {
                expression {
                    return params.skip_checks || env.NEW_IMAGE_AVAILABLE == 'true' || currentBuild.description == 'No running instance found'
                }
            }
            steps {
                script {
                    if (params.DEPLOY_TYPE == 'docker') {
                        // Ensure the correct image tag is used in the docker-compose.yml
                        sh '''
                        sed -i "s|image: .*|image: ${REGISTRY}/${REPOSITORY}:${IMAGE_TAG}|" docker-compose.yml
                        '''
                        // Deploy using Docker Compose
                        sh 'docker-compose down'
                        sh 'docker-compose up -d'

                        // Wait for a few seconds to let the app start
                        sleep 10

                        // Verify the container is running
                        def containerRunning = sh(script: "docker ps -q -f name=${ENV_PROJECT_NAME}", returnStdout: true).trim()
                        if (!containerRunning) {
                            error "Container ${ENV_PROJECT_NAME} is not running"
                        } else {
                            echo "Container ${ENV_PROJECT_NAME} is running"
                            // Execute curl and scale down Kubernetes deployment if curl is successful
                            sh """
                                curl -v http://0.0.0.0:8002 && \\
                                replicas=\$(kubectl get deployment arpansahu-dot-me-app -o=jsonpath='{.spec.replicas}') || true
                                if [ "\$replicas" != "" ] && [ \$replicas -gt 0 ]; then
                                    kubectl scale deployment arpansahu-dot-me-app --replicas=0 && \\
                                    echo 'Kubernetes deployment scaled down successfully.' && \\
                                    sudo sed -i 's|proxy_pass .*;|proxy_pass http://0.0.0.0:8002;|' ${NGINX_CONF} && sudo nginx -s reload
                                else
                                    echo 'No running Kubernetes deployment to scale down.'
                                fi
                            """
                        }
                    } else if (params.DEPLOY_TYPE == 'kubernetes') {
                        // Copy the .env file to the workspace
                        sh "sudo cp /root/projectenvs/${ENV_PROJECT_NAME}/.env ${env.WORKSPACE}/"

                        // Check if the file is copied successfully
                        if (fileExists("${env.WORKSPACE}/.env")) {
                            echo ".env file copied successfully."
                            
                            // Verify Kubernetes configuration
                            sh 'kubectl cluster-info'
                            
                            // Print current directory
                            sh 'pwd'
                            
                            // Delete existing secret if it exists
                            sh '''
                            kubectl delete secret arpansahu-dot-me-secret || true
                            '''

                            // Delete the existing service and deployment
                            sh '''
                            kubectl delete service arpansahu-dot-me-service || true
                            kubectl scale deployment arpansahu-dot-me-app --replicas=0 || true
                            kubectl delete deployment arpansahu-dot-me-app || true
                            '''

                            // Deploy to Kubernetes
                            sh '''
                            kubectl create secret generic arpansahu-dot-me-secret --from-env-file=${WORKSPACE}/.env
                            kubectl apply -f ${WORKSPACE}/service.yaml
                            kubectl apply -f ${WORKSPACE}/deployment.yaml
                            '''
                            
                            // Wait for a few seconds to let the app start
                            sleep 10

                            // Check deployment status
                            sh '''
                            kubectl rollout status deployment/arpansahu-dot-me-app
                            '''
                            
                            // Verify service and get NodePort
                            def nodePort = sh(script: "kubectl get service arpansahu-dot-me-service -o=jsonpath='{.spec.ports[0].nodePort}'", returnStdout: true).trim()
                            echo "Service NodePort: ${nodePort}"

                            // Get cluster IP address
                            def clusterIP = sh(script: "kubectl get nodes -o=jsonpath='{.items[0].status.addresses[0].address}'", returnStdout: true).trim()
                            echo "Cluster IP: ${clusterIP}"

                            // Verify if the service is accessible and delete the Docker container if accessible and update nginx configuration
                            sh """
                                HTTP_STATUS=\$(curl -s -o /dev/null -