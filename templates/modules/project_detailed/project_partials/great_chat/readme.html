<h1>
 Great Chat
</h1>
<p>
 This WhatsApp clone project provides a comprehensive chat application with various advanced features. Below are the main components and functionalities of the project.
</p>
<h2>
 Project Features
</h2>
<ol>
 <li>
  <strong>
   Account Functionality:
  </strong>
  Complete account management.
 </li>
 <li>
  <strong>
   PostgreSql Integration:
  </strong>
  Utilized as a database.
 </li>
 <li>
  <strong>
   AWS S3/MinIO Integration:
  </strong>
  For file storage.
 </li>
 <li>
  <strong>
   Redis Integration:
  </strong>
  Utilized for caching and message pub/sub.
 </li>
 <li>
  <strong>
   Autocomplete JS Library:
  </strong>
  Implemented for enhanced user experience.
 </li>
 <li>
  <strong>
   MailJet Integration:
  </strong>
  Used for email services.
 </li>
 <li>
  <strong>
   Dockerized Project:
  </strong>
  Fully containerized for easy deployment.
 </li>
 <li>
  <strong>
   CI/CD Pipeline:
  </strong>
  Continuous integration and deployment included.
 </li>
</ol>
<h2>
 WhatsApp Clone Functionalities
</h2>
<ol>
 <li>
  <strong>
   Messaging:
  </strong>
 </li>
 <li>
  Send text messages and files.
 </li>
 <li>
  Download files via download links.
 </li>
 <li>
  View images and GIFs directly in the chat.
 </li>
 <li>
  <strong>
   Private Chat:
  </strong>
 </li>
 <li>
  Chat privately with your contacts.
 </li>
 <li>
  Search your private contacts.
 </li>
 <li>
  <strong>
   Group Chat:
  </strong>
 </li>
 <li>
  Chat with friends or others in private groups.
 </li>
 <li>
  Invite people to your private group.
 </li>
 <li>
  Leave a group chat if desired.
 </li>
 <li>
  Admins can delete their own group chats.
 </li>
 <li>
  Remove members from your own group.
 </li>
 <li>
  <strong>
   Global Chat:
  </strong>
 </li>
 <li>
  Participate in a global chat room.
 </li>
 <li>
  <strong>
   Profile Management:
  </strong>
 </li>
 <li>
  Set profile photos.
 </li>
 <li>
  Set group chat photos.
 </li>
 <li>
  <strong>
   Message Display:
  </strong>
 </li>
 <li>
  View the last 30 messages.
 </li>
 <li>
  See user online/offline status.
 </li>
</ol>
<p>
 -Deployed on AWS / Now in My Own Home Ubuntu Server LTS 22.0 / Hostinger VPS Server
</p>
<ol>
 <li>
  Used Ubuntu 22.0 LTS
 </li>
 <li>
  Used Nginx as a Web Proxy Server
 </li>
 <li>
  Used Let's Encrypt Wildcard certificate
 </li>
 <li>
  Used Acme-dns server for automating renewal of wildcard certificates
 </li>
 <li>
  Used docker to run inside a container since other projects are also running on the same server
 </li>
 <li>
  Used Jenkins for CI/CD Integration Jenkins Server Running at: https://jenkins.arpansahu.me
 </li>
 <li>
  Used AWS Elastic Cache for redis which is not accessible outside AWS, Used Redis Server, hosted on Home Server itself as Redis on Home Server
 </li>
 <li>
  Used PostgresSql Schema based Database, all projects are using single Postgresql.
 </li>
 <li>
  PostgresSQL is also hosted on Home Server Itself.
 </li>
 <li>
  Using MINIIO as self hosted S3 Storage Server.
 </li>
</ol>
<h2>
 What is Python ?
</h2>
<p>
 Python is a high-level, general-purpose programming language. Its design philosophy emphasizes code readability with the
 <br/>
 use of significant indentation. Python is dynamically typed and garbage-collected. It supports multiple programming
 <br/>
 paradigms, including structured, object-oriented and functional programming.
</p>
<h2>
 What is Django ?
</h2>
<p>
 Django is a Python-based free and open-source web framework that follows the model-template-view architectural pattern.
</p>
<h2>
 What is Redis ?
</h2>
<p>
 Redis is an in-memory data structure project implementing a distributed, in-memory key-value database with optional durability.
 <br/>
 The most common Redis use cases are session cache, full-page cache, queues, leader boards and counting, publish-subscribe, and much more. in this case, we will use Redis as a message broker.
</p>
<h2>
 What is Ajax?
</h2>
<p>
 Ajax is a set of web development techniques that uses various web technologies on the client-side to create asynchronous web applications. With Ajax, web applications can send and retrieve data from a server asynchronously without interfering with the display and behavior of the existing page.
</p>
<h2>
 Tech Stack
</h2>
<p>
 <a href="https://www.python.org/">
  <img alt="Python" src="https://img.shields.io/badge/Python-3776AB?style=for-the-badge&logo=python&logoColor=white"/>
 </a>
 <br/>
 <a href="https://www.djangoproject.com/">
  <img alt="Django" src="https://img.shields.io/badge/Django-092E20?style=for-the-badge&logo=django&logoColor=white"/>
 </a>
 <br/>
 <a href="https://developer.mozilla.org/en-US/docs/Glossary/HTML5">
  <img alt="HTML5" src="https://img.shields.io/badge/html5-%23E34F26.svg?style=for-the-badge&logo=html5&logoColor=white"/>
 </a>
 <br/>
 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS">
  <img alt="CSS3" src="https://img.shields.io/badge/css3-%231572B6.svg?style=for-the-badge&logo=css3&logoColor=white"/>
 </a>
 <br/>
 <a href="https://getbootstrap.com/">
  <img alt="Bootstrap" src="https://img.shields.io/badge/Bootstrap-563D7C?style=for-the-badge&logo=bootstrap&logoColor=white"/>
 </a>
 <br/>
 <a href="https://www.javascript.com/">
  <img alt="Javascript" src="https://img.shields.io/badge/JavaScript-323330?style=for-the-badge&logo=javascript&logoColor=F7DF1E"/>
 </a>
 <br/>
 <a href="https://redis.io/docs/">
  <img alt="Redis" src="https://img.shields.io/badge/redis-%23DD0031.svg?style=for-the-badge&logo=redis&logoColor=white"/>
 </a>
 <br/>
 <a href="https://www.postgresql.org/docs/">
  <img alt="Postgres" src="https://img.shields.io/badge/postgres-%23316192.svg?style=for-the-badge&logo=postgresql&logoColor=white"/>
 </a>
 <br/>
 <a href="https://heroku.com/">
  <img alt="Heroku" src="https://img.shields.io/badge/-Heroku-430098?style=for-the-badge&logo=heroku&logoColor=white"/>
 </a>
 <br/>
 <a href="https://www.github.com/">
  <img alt="Github" src="https://img.shields.io/badge/GitHub-100000?style=for-the-badge&logo=github&logoColor=white"/>
 </a>
 <br/>
 <a href="https://www.docker.com/">
  <img alt="Docker" src="https://img.shields.io/badge/Docker-2CA5E0?style=for-the-badge&logo=docker&logoColor=white"/>
 </a>
 <br/>
 <a href="https://www.jenkins.io/">
  <img alt="Jenkins" src="https://img.shields.io/badge/Jenkins-D24939?style=for-the-badge&logo=Jenkins&logoColor=white"/>
 </a>
 <br/>
 <a href="https://aws.amazon.com/">
  <img alt="AWS" src="https://img.shields.io/badge/Amazon_AWS-FF9900?style=for-the-badge&logo=amazonaws&logoColor=white"/>
 </a>
 <br/>
 <a href="https://nginx.org/en/">
  <img alt="Nginx" src="https://img.shields.io/badge/Nginx-009639?style=for-the-badge&logo=nginx&logoColor=white"/>
 </a>
 <br/>
 <a href="https://ubuntu.com/">
  <img alt="Ubuntu" src="https://img.shields.io/badge/Ubuntu-E95420?style=for-the-badge&logo=ubuntu&logoColor=white"/>
 </a>
</p>
<h2>
 Demo
</h2>
<p>
 Available at: https://great-chat.arpansahu.me
</p>
<p>
 admin login details:--
 <br/>
 username: admin@arpansahu.me
 <br/>
 password: showmecode
</p>
<h2>
 License
</h2>
<p>
 <a href="https://choosealicense.com/licenses/mit/">
  MIT
 </a>
</p>
<h2>
 Installation
</h2>
<p>
 Installing Pre requisites
</p>
<pre><code class="language-bash">  pip install -r requirements.txt
</code></pre>
<p>
 Create .env File and don't forget to add .env to gitignore
</p>
<pre><code class="language-bash">  add variables mentioned in .env.example
</code></pre>
<p>
 Making Migrations and Migrating them.
</p>
<pre><code class="language-bash">  python manage.py makemigrations
  python manage.py migrate
</code></pre>
<p>
 Run update_data Command
</p>
<pre><code>  python manage.py update_data
</code></pre>
<p>
 Creating Super User
</p>
<pre><code class="language-bash">  python manage.py createsuperuser
</code></pre>
<p>
 Installing Redis On Local (For ubuntu) for other Os Please refer to their website https://redis.io/
</p>
<pre><code class="language-bash">  curl -fsSL https://packages.redis.io/gpg | sudo gpg --dearmor -o /usr/share/keyrings/redis-archive-keyring.gpg
  echo &quot;deb [signed-by=/usr/share/keyrings/redis-archive-keyring.gpg] https://packages.redis.io/deb $(lsb_release -cs) main&quot; | sudo tee /etc/apt/sources.list.d/redis.list
  sudo apt-get update
  sudo apt-get install redis
  sudo systemctl restart redis.service
</code></pre>
<p>
 to check if its running or not
</p>
<pre><code class="language-bash">  sudo systemctl status redis
</code></pre>
<p>
 Run Server
</p>
<pre><code class="language-bash">  python manage.py runserver

  or 

  daphne -p 8000 great_chat.asgi:application
</code></pre>
<p>
 Use these CACHE settings
</p>
<pre><code class="language-python">CACHES = {
    &#x27;default&#x27;: {
        &#x27;BACKEND&#x27;: &#x27;django_redis.cache.RedisCache&#x27;,
        &#x27;LOCATION&#x27;: config(&#x27;REDISCLOUD_URL&#x27;),
        &#x27;OPTIONS&#x27;: {
            &#x27;CLIENT_CLASS&#x27;: &#x27;django_redis.client.DefaultClient&#x27;,
        }
    }
}
</code></pre>
<p>
 Use these Channels Settings
</p>
<pre><code class="language-python">if not DEBUG:
    CHANNEL_LAYERS = {
        &#x27;default&#x27;: {
            &quot;BACKEND&quot;: &quot;channels.layers.InMemoryChannelLayer&quot;,
        }
    }
else:
    CHANNEL_LAYERS = {
        &quot;default&quot;: {
            &quot;BACKEND&quot;: &quot;channels_redis.core.RedisChannelLayer&quot;,
            &quot;CONFIG&quot;: {
                &quot;hosts&quot;: [(config(&#x27;REDISCLOUD_URL&#x27;))],
            },
        },
    }
</code></pre>
<p>
 Change settings.py static files and media files settings | Now I have added support for BlackBlaze Static Storage also which also based on AWS S3 protocols
</p>
<pre><code class="language-python">if not DEBUG:
    BUCKET_TYPE = config(&#x27;BUCKET_TYPE&#x27;)

    if BUCKET_TYPE == &#x27;AWS&#x27;:

        AWS_ACCESS_KEY_ID = config(&#x27;AWS_ACCESS_KEY_ID&#x27;)
        AWS_SECRET_ACCESS_KEY = config(&#x27;AWS_SECRET_ACCESS_KEY&#x27;)
        AWS_STORAGE_BUCKET_NAME = config(&#x27;AWS_STORAGE_BUCKET_NAME&#x27;)
        AWS_S3_CUSTOM_DOMAIN = f&#x27;{AWS_STORAGE_BUCKET_NAME}.s3.amazonaws.com&#x27;
        AWS_DEFAULT_ACL = &#x27;public-read&#x27;
        AWS_S3_OBJECT_PARAMETERS = {
            &#x27;CacheControl&#x27;: &#x27;max-age=86400&#x27;
        }
        AWS_LOCATION = &#x27;static&#x27;
        AWS_QUERYSTRING_AUTH = False
        AWS_HEADERS = {
            &#x27;Access-Control-Allow-Origin&#x27;: &#x27;*&#x27;,
        }
        # s3 static settings
        AWS_STATIC_LOCATION = &#x27;portfolio/great_chat/static&#x27;
        STATIC_URL = f&#x27;https://{AWS_S3_CUSTOM_DOMAIN}/{AWS_STATIC_LOCATION}/&#x27;
        STATICFILES_STORAGE = &#x27;great_chat.storage_backends.StaticStorage&#x27;
        # s3 public media settings
        AWS_PUBLIC_MEDIA_LOCATION = &#x27;portfolio/great_chat/media&#x27;
        MEDIA_URL = f&#x27;https://{AWS_S3_CUSTOM_DOMAIN}/{AWS_PUBLIC_MEDIA_LOCATION}/&#x27;
        DEFAULT_FILE_STORAGE = &#x27;great_chat.storage_backends.PublicMediaStorage&#x27;
        # s3 private media settings
        PRIVATE_MEDIA_LOCATION = &#x27;portfolio/great_chat/private&#x27;
        PRIVATE_FILE_STORAGE = &#x27;great_chat.storage_backends.PrivateMediaStorage&#x27;

    elif BUCKET_TYPE == &#x27;BLACKBLAZE&#x27;:

        AWS_ACCESS_KEY_ID = config(&#x27;AWS_ACCESS_KEY_ID&#x27;)
        AWS_SECRET_ACCESS_KEY = config(&#x27;AWS_SECRET_ACCESS_KEY&#x27;)
        AWS_STORAGE_BUCKET_NAME = config(&#x27;AWS_STORAGE_BUCKET_NAME&#x27;)
        AWS_S3_REGION_NAME = &#x27;us-east-005&#x27;

        AWS_S3_ENDPOINT = f&#x27;s3.{AWS_S3_REGION_NAME}.backblazeb2.com&#x27;
        AWS_S3_ENDPOINT_URL = f&#x27;https://{AWS_S3_ENDPOINT}&#x27;

        AWS_DEFAULT_ACL = &#x27;public-read&#x27;
        AWS_S3_OBJECT_PARAMETERS = {
            &#x27;CacheControl&#x27;: &#x27;max-age=86400&#x27;,
        }

        AWS_LOCATION = &#x27;static&#x27;
        AWS_QUERYSTRING_AUTH = False
        AWS_HEADERS = {
            &#x27;Access-Control-Allow-Origin&#x27;: &#x27;*&#x27;,
        }
        # s3 static settings
        AWS_STATIC_LOCATION = &#x27;portfolio/great_chat/static&#x27;
        STATIC_URL = f&#x27;https://{AWS_STORAGE_BUCKET_NAME}.{AWS_STATIC_LOCATION}/&#x27;
        STATICFILES_STORAGE = &#x27;great_chat.storage_backends.StaticStorage&#x27;
        # s3 public media settings
        AWS_PUBLIC_MEDIA_LOCATION = &#x27;portfolio/great_chat/media&#x27;
        MEDIA_URL = f&#x27;https://{AWS_STORAGE_BUCKET_NAME}.{AWS_PUBLIC_MEDIA_LOCATION}/&#x27;
        DEFAULT_FILE_STORAGE = &#x27;great_chat.storage_backends.PublicMediaStorage&#x27;
        # s3 private media settings
        PRIVATE_MEDIA_LOCATION = &#x27;portfolio/great_chat/private&#x27;
        PRIVATE_FILE_STORAGE = &#x27;great_chat.storage_backends.PrivateMediaStorage&#x27;

    elif BUCKET_TYPE == &#x27;MINIO&#x27;:
        AWS_ACCESS_KEY_ID = config(&#x27;AWS_ACCESS_KEY_ID&#x27;)
        AWS_SECRET_ACCESS_KEY = config(&#x27;AWS_SECRET_ACCESS_KEY&#x27;)
        AWS_STORAGE_BUCKET_NAME = config(&#x27;AWS_STORAGE_BUCKET_NAME&#x27;)
        AWS_S3_REGION_NAME = &#x27;us-east-1&#x27;  # MinIO doesn&#x27;t require this, but boto3 does
        AWS_S3_ENDPOINT_URL = &#x27;https://minio.arpansahu.me&#x27;
        AWS_DEFAULT_ACL = &#x27;public-read&#x27;
        AWS_S3_OBJECT_PARAMETERS = {
            &#x27;CacheControl&#x27;: &#x27;max-age=86400&#x27;,
        }
        AWS_LOCATION = &#x27;static&#x27;
        AWS_QUERYSTRING_AUTH = False
        AWS_HEADERS = {
            &#x27;Access-Control-Allow-Origin&#x27;: &#x27;*&#x27;,
        }

        # s3 static settings
        AWS_STATIC_LOCATION = &#x27;portfolio/great_chat/static&#x27;
        STATIC_URL = f&#x27;https://{AWS_STORAGE_BUCKET_NAME}/{AWS_STATIC_LOCATION}/&#x27;
        STATICFILES_STORAGE = &#x27;great_chat.storage_backends.StaticStorage&#x27;

        # s3 public media settings
        AWS_PUBLIC_MEDIA_LOCATION = &#x27;portfolio/great_chat/media&#x27;
        MEDIA_URL = f&#x27;https://{AWS_STORAGE_BUCKET_NAME}/{AWS_PUBLIC_MEDIA_LOCATION}/&#x27;
        DEFAULT_FILE_STORAGE = &#x27;great_chat.storage_backends.PublicMediaStorage&#x27;

        # s3 private media settings
        PRIVATE_MEDIA_LOCATION = &#x27;portfolio/great_chat/private&#x27;
        PRIVATE_FILE_STORAGE = &#x27;great_chat.storage_backends.PrivateMediaStorage&#x27;



else:
    # Static files (CSS, JavaScript, Images)
    # https://docs.djangoproject.com/en/3.2/howto/static-files/

    STATIC_URL = &#x27;/static/&#x27;

    STATIC_ROOT = os.path.join(BASE_DIR, &#x27;staticfiles&#x27;)
    MEDIA_URL = &#x27;/media/&#x27;

MEDIA_ROOT = os.path.join(BASE_DIR, &#x27;media&#x27;)
STATICFILES_DIRS = [os.path.join(BASE_DIR, &quot;static&quot;), ]
</code></pre>
<p>
 run below command
</p>
<pre><code class="language-bash">python manage.py collectstatic
</code></pre>
<p>
 and you are good to go
</p>
<h2>
 Custom Django Management Commands
</h2>
<ol>
 <li>
  Test DB
  <br/>
  Django management command designed to test the basic functionality of the database. It performs a series of CRUD (Create, Read, Update, Delete) operations to ensure the database is working correctly.
 </li>
</ol>
<pre><code class="language-bash">python manage.py test_db
</code></pre>
<ol>
 <li>
  Test Cache
  <br/>
  Django management command designed to test the basic functionality of the caching system. It performs a set and get operation to ensure the cache is working correctly and validates the expiration of cache entries.
 </li>
</ol>
<pre><code class="language-bash">python manage.py test_cache
</code></pre>
<ol>
 <li>
  Test Channels
  <br/>
  Django management command designed to test the functionality of Django Channels, ensuring that it is properly configured and operational.
 </li>
</ol>
<pre><code class="language-bash">python manage.py test_channels
</code></pre>
<ol>
 <li>
  Sync Media to S3
  <br/>
  In case if you are using production database and debug mode is on. all the media send in the chats will be stored to local media folder which might not get synced to s3 bucket and when you run in production those media will be missing.
 </li>
</ol>
<pre><code class="language-bash">python manage.py sync_media_to_s3
</code></pre>
<h2>
 Readme Manager
</h2>
<p>
 Each repository contains an
 <code>
  update_readme.sh
 </code>
 script located in the
 <code>
  readme_manager
 </code>
 directory. This script is responsible for updating the README file in the repository by pulling in content from various sources.
</p>
<h3>
 What it Does
</h3>
<p>
 The
 <code>
  update_readme.sh
 </code>
 script performs the following actions:
</p>
<ol>
 <li>
  <strong>
   Clone Required Files
  </strong>
  : Clones the
  <code>
   requirements.txt
  </code>
  ,
  <code>
   readme_updater.py
  </code>
  , and
  <code>
   baseREADME.md
  </code>
  files from the
  <code>
   common_readme
  </code>
  repository.
 </li>
 <li>
  <strong>
   Set Up Python Environment
  </strong>
  : Creates and activates a Python virtual environment.
 </li>
 <li>
  <strong>
   Install Dependencies
  </strong>
  : Installs the necessary dependencies listed in
  <code>
   requirements.txt
  </code>
  .
 </li>
 <li>
  <strong>
   Run Update Script
  </strong>
  : Executes the
  <code>
   readme_updater.py
  </code>
  script to update the README file using
  <code>
   baseREADME.md
  </code>
  and other specified sources.
 </li>
 <li>
  <strong>
   Clean Up
  </strong>
  : Deactivates the Python virtual environment and removes it.
 </li>
</ol>
<h3>
 How to Use
</h3>
<p>
 To run the
 <code>
  update_readme.sh
 </code>
 script, navigate to the
 <code>
  readme_manager
 </code>
 directory and execute the script:
</p>
<pre><code class="language-bash">cd readme_manager &amp;&amp; ./update_readme.sh
</code></pre>
<p>
 This will update the
 <code>
  README.md
 </code>
 file in the root of the repository with the latest content from the specified sources.
</p>
<h3>
 Updating Content
</h3>
<p>
 If you need to make changes that are specific to the project or project-specific files, you might need to update the content of the partial README files. Here are the files that are included:
</p>
<ul>
 <li>
  <strong>
   Project-Specific Files
  </strong>
  :
 </li>
 <li>
  <code>
   env.example
  </code>
 </li>
 <li>
  <code>
   docker-compose.yml
  </code>
 </li>
 <li>
  <code>
   Dockerfile
  </code>
 </li>
 <li>
  <p>
   <code>
    Jenkinsfile
   </code>
  </p>
 </li>
 <li>
  <p>
   <strong>
    Project-Specific Partial Files
   </strong>
   :
  </p>
 </li>
 <li>
  <code>
   INTRODUCTION
  </code>
  :
  <code>
   ../readme_manager/partials/introduction.md
  </code>
 </li>
 <li>
  <code>
   DOC_AND_STACK
  </code>
  :
  <code>
   ../readme_manager/partials/documentation_and_stack.md
  </code>
 </li>
 <li>
  <code>
   TECHNOLOGY QNA
  </code>
  :
  <code>
   ../readme_manager/partials/technology_qna.md
  </code>
 </li>
 <li>
  <code>
   DEMO
  </code>
  :
  <code>
   ../readme_manager/partials/demo.md
  </code>
 </li>
 <li>
  <code>
   INSTALLATION
  </code>
  :
  <code>
   ../readme_manager/partials/installation.md
  </code>
 </li>
 <li>
  <code>
   DJANGO_COMMANDS
  </code>
  :
  <code>
   ../readme_manager/partials/django_commands.md
  </code>
 </li>
 <li>
  <code>
   NGINX_SERVER
  </code>
  :
  <code>
   ../readme_manager/partials/nginx_server.md
  </code>
 </li>
</ul>
<p>
 These files are specific to the project and should be updated within the project repository.
</p>
<ul>
 <li>
  <strong>
   Common Files
  </strong>
  :
 </li>
 <li>
  All other files are common across projects and should be updated in the
  <code>
   common_readme
  </code>
  repository.
 </li>
</ul>
<p>
 There are a few files which are common for all projects. For convenience, these are inside the
 <code>
  common_readme
 </code>
 repository so that if changes are made, they will be updated in all the projects' README files.
</p>
<pre><code class="language-python"># Define a dictionary with the placeholders and their corresponding GitHub raw URLs or local paths

include_files = {
    # common files

    &quot;README of Docker Installation&quot;: &quot;https://raw.githubusercontent.com/arpansahu/common_readme/main/Docker%20Readme/docker_installation.md&quot;,
    &quot;DOCKER_END&quot;: &quot;https://raw.githubusercontent.com/arpansahu/common_readme/main/Docker%20Readme/docker_end.md&quot;,
    &quot;README of Nginx Setup&quot;: &quot;https://raw.githubusercontent.com/arpansahu/common_readme/main/AWS%20Deployment/nginx.md&quot;,
    &quot;README of Nginx HTTPS Setup&quot;: &quot;https://raw.githubusercontent.com/arpansahu/common_readme/main/AWS%20Deployment/nginx_https.md&quot;,
    &quot;README of Jenkins Setup&quot;: &quot;https://raw.githubusercontent.com/arpansahu/common_readme/main/AWS%20Deployment/Jenkins/Jenkins.md&quot;,
    &quot;JENKINS_END&quot;: &quot;https://raw.githubusercontent.com/arpansahu/common_readme/main/AWS%20Deployment/Jenkins/jenkins_end.md&quot;,
    &quot;README of PostgreSql Server With Nginx Setup&quot;: &quot;https://raw.githubusercontent.com/arpansahu/common_readme/main/AWS%20Deployment/Postgres.md&quot;,
    &quot;README of PGAdmin4 Server With Nginx Setup&quot;: &quot;https://raw.githubusercontent.com/arpansahu/common_readme/main/AWS%20Deployment/Pgadmin.md&quot;,
    &quot;README of Portainer Server With Nginx Setup&quot;: &quot;https://raw.githubusercontent.com/arpansahu/common_readme/main/AWS%20Deployment/Portainer.md&quot;,
    &quot;README of Redis Server Setup&quot;: &quot;https://raw.githubusercontent.com/arpansahu/common_readme/main/AWS%20Deployment/Redis.md&quot;,
    &quot;README of Redis Commander Setup&quot;: &quot;https://raw.githubusercontent.com/arpansahu/common_readme/main/AWS%20Deployment/RedisComander.md&quot;,
    &quot;README of Minio Server Setup&quot;: &quot;https://raw.githubusercontent.com/arpansahu/common_readme/main/AWS%20Deployment/Minio.md&quot;,
    &quot;README of Intro&quot;: &quot;https://raw.githubusercontent.com/arpansahu/common_readme/main/AWS%20Deployment/Intro.md&quot;,
    &quot;README of Readme Manager&quot;: &quot;https://raw.githubusercontent.com/arpansahu/common_readme/main/Readme%20manager/readme_manager.md&quot;,
    &quot;AWS DEPLOYMENT INTRODUCTION&quot;: &quot;https://raw.githubusercontent.com/arpansahu/common_readme/main/Introduction/aws_desployment_introduction.md&quot;,
    &quot;STATIC_FILES&quot;: &quot;https://raw.githubusercontent.com/arpansahu/common_readme/main/Introduction/static_files_settings.md&quot;,
    &quot;README of Harbor&quot; : &quot;https://raw.githubusercontent.com/arpansahu/common_readme/main/AWS%20Deployment/harbor/harbor.md&quot;,
    &quot;HARBOR DOCKER COMPOSE&quot;: &quot;https://raw.githubusercontent.com/arpansahu/common_readme/main/AWS%20Deployment/harbor/docker-compose.yml&quot;,
    &quot;INCLUDE FILES&quot;: &quot;https://raw.githubusercontent.com/arpansahu/common_readme/main/include_files.py&quot;,

    # project files
    &quot;env.example&quot;: &quot;../env.example&quot;,
    &quot;docker-compose.yml&quot;: &quot;../docker-compose.yml&quot;,
    &quot;Dockerfile&quot;: &quot;../Dockerfile&quot;,
    &quot;Jenkinsfile&quot;: &quot;../Jenkinsfile&quot;,

    # project partials files
    &quot;INTRODUCTION&quot;: &quot;../readme_manager/partials/introduction.md&quot;,
    &quot;DOC_AND_STACK&quot;: &quot;../readme_manager/partials/documentation_and_stack.md&quot;,
    &quot;TECHNOLOGY QNA&quot;: &quot;../readme_manager/partials/technology_qna.md&quot;,
    &quot;DEMO&quot;: &quot;../readme_manager/partials/demo.md&quot;,
    &quot;INSTALLATION&quot;: &quot;../readme_manager/partials/installation.md&quot;,
    &quot;DJANGO_COMMANDS&quot;: &quot;../readme_manager/partials/django_commands.md&quot;,
    &quot;NGINX_SERVER&quot;: &quot;../readme_manager/partials/nginx_server.md&quot;,
}
</code></pre>
<p>
 Also, remember if you want to include new files, you need to change the
 <code>
  baseREADME
 </code>
 file and the
 <code>
  include_files
 </code>
 array in the
 <code>
  common_readme
 </code>
 repository itself.
</p>
<h2>
 Deployment on AWS EC2/ Home Server Ubuntu 22.0 LTS/ Hostinger VPS Server
</h2>
<p>
 Previously This project was hosted on Heroku, but so I started hosting this and all other projects in a
 <br/>
 Single EC2 Machine, which cost me a lot, so now I have shifted all the projects to my own Home Server with
 <br/>
 Ubuntu 22.0 LTS Server, except for portfolio project at https://www.arpansahu.me along with Nginx
</p>
<p>
 Now there is an EC2 server running with an nginx server and arpansahu.me portfolio
 <br/>
 Nginx forwarded https://arpansahu.me/ to the Home Server
</p>
<p>
 Multiple Projects are running inside dockers so all projects are dockerized.
 <br/>
 You can refer to all projects at https://www.arpansahu.me/projects
</p>
<p>
 Every project has a different port on which it runs predefined inside Dockerfile and docker-compose.yml
</p>
<p>
 <img alt="EC2 and Home Server along with Nginx, Docker and Jenkins Arrangement" class="d-block w-100" src="https://raw.githubusercontent.com/arpansahu/common_readme/main/Images/ec2_and_home_server.png"/>
</p>
<p>
 Note: Update as of Aug 2023, I have decided to make some changes to my lifestyle, and from now I will be constantly on the go
 <br/>
 from my experience with running a free EC2 server for arpansahu. me and nginx in it and then using another home server
 <br/>
 with all the other projects hosted, my experience was
</p>
<ol>
 <li>
  Downtime due to Broadband Service Provider Issues
 </li>
 <li>
  Downtime due to Weather Sometimes
 </li>
 <li>
  Downtime due to Machine Breakdown
 </li>
 <li>
  Downtime due to Power Cuts (even though I had an inverted battery setup for my room)
 </li>
 <li>
  Remotely it would be harder to fix these problems
 </li>
</ol>
<p>
 and due to all these reasons I decided to shift all the projects to a single EC2 Server, at first I was using t2.medium which costs more than 40$ a month
 <br/>
 then I switched to t2.small and it only costs you 15$ if we take pre-paid plans prices can be slashed much further.
</p>
<p>
 Then again I shifted to Hostinger VPS which was more cost-friendly than EC2 Server. On Jan 2024
</p>
<p>
 Now My project arrangements look something similar to this
</p>
<p>
 <img alt="EC2 Sever along with Nginx, Docker and Jenkins Arrangement" class="d-block w-100" src="https://raw.githubusercontent.com/arpansahu/common_readme/main/Images/One%20Server%20Configuration%20for%20arpanahuone.png"/>
</p>
<h3>
 Step 1: Dockerize
</h3>
<h4>
 Installing Redis Commander
</h4>
<p>
 Reference: https://docs.docker.com/engine/install/ubuntu/
</p>
<ol>
 <li>
  Setting up the Repository
 </li>
 <li>
  Update the apt package index and install packages to allow apt to use a repository over HTTPS:
 </li>
</ol>
<pre><code class="language-bash">       sudo apt-get update

       sudo apt-get install \
       ca-certificates \
       curl \
       gnupg \
       lsb-release
</code></pre>
<ol>
 <li>
  Add Docker’s official GPG key:
 </li>
</ol>
<pre><code class="language-bash">       sudo mkdir -p /etc/apt/keyrings

       curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
</code></pre>
<ol>
 <li>
  Use the following command to set up the repository:
 </li>
</ol>
<pre><code class="language-bash">       echo \
         &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
         $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null
</code></pre>
<ol>
 <li>
  <p>
   Install Docker Engine
  </p>
 </li>
 <li>
  <p>
   Update the apt package index:
  </p>
 </li>
</ol>
<pre><code class="language-bash">       sudo apt-get update
</code></pre>
<pre><code>  1. Receiving a GPG error when running apt-get update?

     Your default umask may be incorrectly configured, preventing detection of the repository public key file. Try granting read permission for the Docker public key file before updating the package index:
</code></pre>
<pre><code class="language-bash">            sudo chmod a+r /etc/apt/keyrings/docker.gpg
            sudo apt-get update
</code></pre>
<ol>
 <li>
  Install Docker Engine, containerd, and Docker Compose.
 </li>
</ol>
<pre><code class="language-bash">        sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin
</code></pre>
<ol>
 <li>
  Verify that the Docker Engine installation is successful by running the hello-world image:
 </li>
</ol>
<pre><code class="language-bash">         sudo docker run hello-world
</code></pre>
<p>
 Now in your Git Repository
</p>
<p>
 Create a file named Dockerfile with no extension and add following lines in it
</p>
<h3>
 Step 2: Private Docker Registry
</h3>
<h2>
 Harbor (Self hosted Private Docker Registry)
</h2>
<p>
 Harbor is an open-source container image registry that secures images with role-based access control, scans images for vulnerabilities, and signs images as trusted. It extends the Docker Distribution by adding functionalities usually required by enterprise users, such as security, identity, and management.
</p>
<h3>
 Installing Harbor
</h3>
<ol>
 <li>
  <strong>
   Download Harbor:
  </strong>
  <br/>
  Go to the Harbor releases page and download the latest offline installer tarball, e.g., harbor-offline-installer-
  <version>
   .tgz.
   <br/>
   Alternatively, you can use wget to download it directly:
  </version>
 </li>
</ol>
<pre><code class="language-bash">    wget https://github.com/goharbor/harbor/releases/download/v2.4.2/harbor-offline-installer-v2.4.2.tgz
</code></pre>
<ol>
 <li>
  <strong>
   Extract the tarball:
  </strong>
 </li>
</ol>
<pre><code class="language-bash">    tar -zxvf harbor-offline-installer-&lt;version&gt;.tgz
    cd harbor
</code></pre>
<ol>
 <li>
  <p>
   <strong>
    Configure Harbor:
   </strong>
   <br/>
   Note: I am having multiple projects running in single machine and 1 nginx is handling subdomains and domain arpansahu.me. Similarly i want my harbor to be accessible
   <br/>
   from harbor.arpansahu.me.
  </p>
  <ol>
   <li>
    Copy and edit the configuration file:
   </li>
  </ol>
 </li>
</ol>
<pre><code class="language-bash">        cp harbor.yml.tmpl harbor.yml
        vi harbor.yml
</code></pre>
<pre><code>2. Edit harbor.yml
</code></pre>
<pre><code class="language-bash">        # Configuration file of Harbor

        # The IP address or hostname to access admin UI and registry service.
        # DO NOT use localhost or 127.0.0.1, because Harbor needs to be accessed by external clients.
        hostname: harbor.arpansahu.me

        # http related config
        http:
        # port for http, default is 80. If https enabled, this port will redirect to https port
        port: 8081
        # https related config
        https:
        # https port for harbor, default is 443
        port: 8443
        # The path of cert and key files for nginx
        certificate: /etc/letsencrypt/live/arpansahu.me/fullchain.pem 
        private_key: /etc/letsencrypt/live/arpansahu.me/privkey.pem


        .......
        more lines
        .......
</code></pre>
<pre><code>    There are almost 250 lines of code in this yml file but we have to make sure to edit this much configuration particularly 
    default http port is 80 and https port is 443 since default harbor docker-compose.yml have nginx setup also. But we have our own nginx
    thats why we will change these both ports to available free port on the machine. I picked 8081 for http and 8443 for https. You can choose accordingly.


3. Edit docker-compose.yml
</code></pre>
<pre><code class="language-bash">            vi docker-compose.yml
</code></pre>
<pre><code class="language-bash">
</code></pre>
<pre><code>    As you can see the ports we used in harbor.yml are configured here and nginx service have been removed.
    ports:
      - 8081:8080
      - 8443:8443
      - 4443:4443
</code></pre>
<ol>
 <li>
  <strong>
   Run the Harbor install script:
  </strong>
 </li>
</ol>
<pre><code class="language-bash">    sudo ./install.sh --with-notary --with-trivy --with-chartmuseum
</code></pre>
<ol>
 <li>
  <strong>
   Complete Setup:
  </strong>
  <br/>
  Follow the on-screen instructions to complete the setup process. You may choose to deploy a local agent for better performance, but it's not required for basic functionality.
 </li>
</ol>
<p>
 Once the setup is complete, you should have access to the Portainer dashboard, where you can manage and monitor your Docker containers, images, volumes, and networks through a user-friendly web interface.
</p>
<p>
 Keep in mind that the instructions provided here assume a basic setup. For production environments, it's recommended to secure the Portainer instance, such as by using HTTPS and setting up authentication. Refer to the
 <a href="https://documentation.portainer.io/">
  Portainer documentation
 </a>
 for more advanced configurations and security considerations.
</p>
<h3>
 Configuring Nginx as Reverse proxy
</h3>
<ol>
 <li>
  Edit Nginx Configuration
 </li>
</ol>
<pre><code class="language-bash">    sudo vi /etc/nginx/sites-available/arpansahu
</code></pre>
<ol>
 <li>
  Add this server configuration
 </li>
</ol>
<pre><code class="language-bash">    server {
        listen         80;
        server_name    harbor.arpansahu.me;
        # force https-redirects
        if ($scheme = http) {
            return 301 https://$server_name$request_uri;
            }

        location / {
            proxy_pass              https://127.0.0.1:8443;
            proxy_set_header        Host $host;
            proxy_set_header    X-Forwarded-Proto $scheme;
        }

        listen 443 ssl; # managed by Certbot
        ssl_certificate /etc/letsencrypt/live/arpansahu.me/fullchain.pem; # managed by Certbot
        ssl_certificate_key /etc/letsencrypt/live/arpansahu.me/privkey.pem; # managed by Certbot
        include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot
        ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot
    }
</code></pre>
<ol>
 <li>
  Test the Nginx Configuration
 </li>
</ol>
<pre><code class="language-bash">    sudo nginx -t
</code></pre>
<ol>
 <li>
  Reload Nginx to apply the new configuration
 </li>
</ol>
<pre><code class="language-bash">    sudo systemctl reload nginx
</code></pre>
<h3>
 Access Harbor UI
</h3>
<p>
 Harbor UI can be accessed here : https://portainer.arpansahu.me/
</p>
<h3>
 Connecting Docker Registry
</h3>
<p>
 Login to Docker Registry
</p>
<p>
 You can connect to my Docker Registry
</p>
<pre><code class="language-bash">    docker login harbor.arpansahu.me
</code></pre>
<pre><code class="language-bash">FROM python:3.10.7

WORKDIR /app

COPY requirements.txt requirements.txt

COPY . .

RUN pip3 install -r requirements.txt

EXPOSE 8002

CMD python manage.py collectstatic
CMD gunicorn --bind 0.0.0.0:8002 great_chat.wsgi
</code></pre>
<p>
 Create a file named docker-compose.yml and add following lines in it
</p>
<pre><code class="language-bash">version: &#x27;3&#x27;

services:
  web:
    build: .
    env_file: ./.env
    command: bash -c &quot;python manage.py makemigrations &amp;&amp; python manage.py migrate &amp;&amp; daphne -b 0.0.0.0 -p 8002 great_chat.asgi:application&quot;
    container_name: great_chat
    volumes:
      - .:/great_chat
    ports:
      - &quot;8002:8002&quot;
    restart: unless-stopped
</code></pre>
<h3>
 <strong>
  What is Difference in Dockerfile and docker-compose.yml?
 </strong>
</h3>
<p>
 A Dockerfile is a simple text file that contains the commands a user could call to assemble an image whereas Docker Compose is a tool for defining and running multi-container Docker applications.
</p>
<p>
 Docker Compose define the services that make up your app in docker-compose.yml so they can be run together in an isolated environment. It gets an app running in one command by just running docker-compose up. Docker compose uses the Dockerfile if you add the build command to your project’s docker-compose.yml. Your Docker workflow should be to build a suitable Dockerfile for each image you wish to create, then use compose to assemble the images using the build command.
</p>
<p>
 Running Docker
</p>
<pre><code class="language-bash">docker compose up --build --detach 
</code></pre>
<p>
 --detach tag is for running the docker even if terminal is closed
 <br/>
 if you remove this tag it will be attached to terminal, and you will be able to see the logs too
</p>
<p>
 --build tag with docker compose up will force image to be rebuild every time before starting the container
</p>
<h3>
 Step 3: Serving the requests from Nginx
</h3>
<h4>
 Installing the Nginx server
</h4>
<pre><code class="language-bash">sudo apt-get install nginx
</code></pre>
<p>
 Starting Nginx and checking its status
</p>
<pre><code class="language-bash">sudo systemctl start nginx
sudo systemctl status nginx
</code></pre>
<h4>
 Modify DNS Configurations
</h4>
<p>
 Add these two records to your DNS Configurations
</p>
<pre><code class="language-bash">A Record    *   0.227.49.244 (public IP of ec2) Automatic
A Record    @   0.227.49.244 (public IP of ec2) Automatic
</code></pre>
<p>
 Note: now you will be able to see nginx running page if you open the public IP of the machine
 <br/>
 IP
 <br/>
 Make Sure your EC2 security Group have these entry inbound rules
</p>
<pre><code class="language-bash">random-hash-id  IPv4    HTTP    TCP 80  0.0.0.0/0   –
</code></pre>
<p>
 Open a new Nginx Configuration file name can be anything i am choosing arpansahu since my domain is arpansahu.me. there is already a default configuration file but we will leave it like that only
</p>
<pre><code class="language-bash">sudo vi /etc/nginx/sites-available/arpansahu
</code></pre>
<p>
 paste this content in the above file
</p>
<pre><code class="language-bash">server_tokens               off;
access_log                  /var/log/nginx/supersecure.access.log;
error_log                   /var/log/nginx/supersecure.error.log;

server {
  server_name               arpansahu.me;        
  listen                    80;
  location / {
    proxy_pass              http://{ip_of_home_server/localhost}:8000;
    proxy_set_header        Host $host;
  }
}
</code></pre>
<p>
 This single Nginx File will be hosting all the multiple projects which I have listed before also.
</p>
<p>
 Checking if the configurations file is correct
</p>
<pre><code class="language-bash">sudo service nginx configtest /etc/nginx/sites-available/arpansahu
</code></pre>
<p>
 Now you need to symlink this file to the sites-enabled directory:
</p>
<pre><code class="language-bash">cd /etc/nginx/sites-enabled
sudo ln -s ../sites-available/arpansahu
</code></pre>
<p>
 Restarting Nginx Server
</p>
<pre><code class="language-bash">sudo systemctl restart nginx
</code></pre>
<p>
 Now it's time to enable HTTPS for this server
</p>
<h3>
 Step 4: Enabling HTTPS
</h3>
<ol>
 <li>
  <p>
   Base Domain:  Enabling HTTPS for base domain only or a single subdomain
  </p>
  <p>
   To allow visitors to access your site over HTTPS, you’ll need an SSL/TLS certificate that sits on your web server. Certificates are issued by a Certificate Authority (CA). We’ll use a free CA called Let’s Encrypt. To install the certificate, you can use the Certbot client, which gives you an utterly painless step-by-step series of prompts.
   <br/>
   Before starting with Certbot, you can tell Nginx up front to disable TLS versions 1.0 and 1.1 in favour of versions 1.2 and 1.3. TLS 1.0 is end-of-life (EOL), while TLS 1.1 contained several vulnerabilities that were fixed by TLS 1.2. To do this, open the file /etc/nginx/nginx.conf. Find the following line:
  </p>
  <p>
   Open nginx.conf file end change ssl_protocols
  </p>
 </li>
</ol>
<pre><code class="language-bash">    sudo vi /etc/nginx/nginx.conf

    From ssl_protocols TLSv1 TLSv1.1 TLSv1.2; to ssl_protocols TLSv1.2 TLSv1.3;
</code></pre>
<pre><code>Use this command to verify if nginx.conf file is correct or not
</code></pre>
<pre><code class="language-bash">    sudo nginx -t
</code></pre>
<pre><code>Now you’re ready to install and use Certbot, you can use Snap to install Certbot:
</code></pre>
<pre><code class="language-bash">    sudo snap install --classic certbot
    sudo ln -s /snap/bin/certbot /usr/bin/certbot
</code></pre>
<pre><code>Now installing certificate
</code></pre>
<pre><code class="language-bash">    sudo certbot --nginx --rsa-key-size 4096 --no-redirect
</code></pre>
<pre><code>It will ask for the domain name then you can enter your base domain 
I have generated SSL for arpansahu.me

Then a few questions will be asked answer them all and your SSL certificate will be generated

Now These lines will be added to your # Nginx configuration: /etc/nginx/sites-available/arpansahu
</code></pre>
<pre><code class="language-bash">    listen 443 ssl;
    ssl_certificate /etc/letsencrypt/live/www.supersecure.codes/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/www.supersecure.codes/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;
</code></pre>
<pre><code>Redirecting HTTP to HTTPS
Open the nginx configuration file  and make it like this
</code></pre>
<pre><code class="language-bash">    sudo vi /etc/nginx/sites-available/arpansahu
</code></pre>
<pre><code class="language-bash">    server_tokens               off;
    access_log                  /var/log/nginx/supersecure.access.log;
    error_log                   /var/log/nginx/supersecure.error.log;

    server {
      server_name               arpansahu.me;
      listen                    80;
      return                    307 https://$host$request_uri;
    }

    server {

      location / {
        proxy_pass              http://{ip_of_home_server/ localhost}:8000;
        proxy_set_header        Host $host;

        listen 443 ssl; # managed by Certbot
        ssl_certificate /etc/letsencrypt/live/arpansahu.me/fullchain.pem; # managed by Certbot
        ssl_certificate_key /etc/letsencrypt/live/arpansahu.me/privkey.pem; # managed by Certbot
        include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot
        ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot
    }                          
</code></pre>
<pre><code>You can dry run and check whether it&#x27;s renewal is working or not
</code></pre>
<pre><code class="language-bash">    sudo certbot renew --dry-run
</code></pre>
<pre><code>Note: this process was for arpansahu.me and not for all subdomains.
For all subdomains, we will have to set a wildcard SSL certificate
</code></pre>
<ol>
 <li>
  <p>
   Enabling a Wildcard certificate
  </p>
  <p>
   Here we will enable an SSL certificate for all subdomains at once
  </p>
  <p>
   Run the following Command
  </p>
 </li>
</ol>
<pre><code class="language-bash">    sudo certbot certonly --manual --preferred-challenges dns
</code></pre>
<pre><code>Again you will be asked domain name and here you will use *.arpansahu.me. and second domain you will use is
arpansahu.me.

Now, you should have a question in your mind about why we are generating SSL for arpansahu.me separately.
It&#x27;s because Let&#x27;s Encrypt does not include a base domain with wildcard certificates for subdomains.

After running the above command you will see a message similar to this
</code></pre>
<pre><code class="language-bash">    Saving debug log to /var/log/letsencrypt/letsencrypt.log
    Please enter the domain name(s) you would like on your certificate (comma and/or
    space separated) (Enter &#x27;c&#x27; to cancel): *.arpansahu.me
    Requesting a certificate for *.arpansahu.me

    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    Please deploy a DNS TXT record under the name:

    _acme-challenge.arpansahu.me.

    with the following value:

    dpWCxvq3mARF5iGzSfaRNXwmdkUSs0wgsTPhSaX1gK4

    Before continuing, verify the TXT record has been deployed. Depending on the DNS
    provider, this may take some time, from a few seconds to multiple minutes. You can
    check if it has finished deploying with the aid of online tools, such as Google
    Admin Toolbox: https://toolbox.googleapps.com/apps/dig/#TXT/_acme-challenge.arpansahu.me.
    Look for one or more bolded line(s) below the line &#x27;; ANSWER&#x27;. It should show the
    value(s) you&#x27;ve just added.

    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    Press Enter to Continue
</code></pre>
<pre><code>You will be given a DNS challenge called ACME challenger you have to create a DNS TXT record in DNS.
Similar to the below record.
</code></pre>
<pre><code class="language-bash">    TXT Record  _acme-challenge dpWCxvq3mARF5iGzSfaRNXwmdkUSs0wgsTPhSaX1gK4 5 Automatic
</code></pre>
<pre><code>Now, use this URL to verify whether records are updated or not

https://toolbox.googleapps.com/apps/dig/#TXT/_acme-challenge.arpansahu.me (arpansahu.me is domain)

If it&#x27;s verified then press enter the terminal as mentioned above

Then your certificate will be generated
</code></pre>
<pre><code class="language-bash">    Successfully received a certificate.
    The certificate is saved at: /etc/letsencrypt/live/arpansahu.me-0001/fullchain.pem            (use this in your nginx configuration file)
    Key is saved at:         /etc/letsencrypt/live/arpansahu.me-0001/privkey.pem
    This certificate expires on 2023-01-20.
    These files will be updated when the certificate is renewed.
</code></pre>
<pre><code>You can notice here, the certificate generated is arpansahu.me-0001 and not arpansahu.me
because we already generated a certificate named arpansahu.me

So remember to delete it before generating this wildcard certificate
using command
</code></pre>
<pre><code class="language-bash">    sudo certbot delete
</code></pre>
<pre><code>Note: This certificate will not be renewed automatically. Auto-renewal of --manual certificates requires the use of an authentication hook script (--manual-auth-hook) but one was not provided. To renew this certificate, repeat this same Certbot command before the certificate&#x27;s expiry date.
</code></pre>
<ol>
 <li>
  <p>
   Generating Wildcard SSL certificate and Automating its renewal
  </p>
  <ol>
   <li>
    Modify your ec2 inbound rules
   </li>
  </ol>
 </li>
</ol>
<pre><code class="language-bash">      – sgr-0219f1387d28c96fb   IPv4    DNS (TCP)   TCP 53  0.0.0.0/0   –   
      – sgr-01b2b32c3cee53aa9   IPv4    SSH TCP 22  0.0.0.0/0   –
      – sgr-0dfd03bbcdf60a4f7   IPv4    HTTP    TCP 80  0.0.0.0/0   –
      – sgr-02668dff944b9b87f   IPv4    HTTPS   TCP 443 0.0.0.0/0   –
      – sgr-013f089a3f960913c   IPv4    DNS (UDP)   UDP 53  0.0.0.0/0   –
</code></pre>
<ol>
 <li>
  <p>
   Install acme-dns Server
  </p>
  <ul>
   <li>
    Create a folder for acme-dns and change the directory
   </li>
  </ul>
 </li>
</ol>
<pre><code class="language-bash">         sudo mkdir /opt/acme-dns
         cd !$
</code></pre>
<pre><code>  * Download and extract tar with acme-dns from GitHub
</code></pre>
<pre><code class="language-bash">        sudo curl -L -o acme-dns.tar.gz \
        https://github.com/joohoi/acme-dns/releases/download/v0.8/acme-dns_0.8_linux_amd64.tar.gz
        sudo tar -zxf acme-dns.tar.gz
</code></pre>
<pre><code>  * List files
</code></pre>
<pre><code class="language-bash">        sudo ls
</code></pre>
<pre><code>  * Clean Up
</code></pre>
<pre><code class="language-bash">        sudo rm acme-dns.tar.gz
</code></pre>
<pre><code>  * Create a soft link
</code></pre>
<pre><code class="language-bash">        sudo ln -s \
        /opt/acme-dns/acme-dns /usr/local/bin/acme-dns
</code></pre>
<pre><code>  * Create a minimal acme-dns user
</code></pre>
<pre><code class="language-bash">         sudo adduser \
         --system \ 
         --gecos &quot;acme-dns Service&quot; \
         --disabled-password \
         --group \
         --home /var/lib/acme-dns \
         acme-dns
</code></pre>
<pre><code>  * Update default acme-dns config compared with IP from the AWS console. Can&#x27;t bind to the public address need to use private one.
</code></pre>
<pre><code class="language-bash">        IP addr

        sudo mkdir -p /etc/acme-dns

        sudo mv /opt/acme-dns/config.cfg /etc/acme-dns/

        sudo vim /etc/acme-dns/config.cfg
</code></pre>
<pre><code>  * Replace
</code></pre>
<pre><code class="language-bash">        listen = &quot;127.0.0.1:53” to listen = “private IP of the ec2 instance” 172.31.93.180:53(port will be 53)

        Similarly, Edit other details mentioned below  

        # domain name to serve the requests off of
        domain = &quot;auth.arpansahu.me&quot;
        # zone name server
        nsname = &quot;auth.arpansahu.me&quot;
        # admin email address, where @ is substituted with .
        nsadmin = &quot;admin@arpansahu.me&quot;


        records = [
          # domain pointing to the public IP of your acme-dns server
           &quot;auth.arpansahu.me. A 44.199.177.138. (public elastic IP)”,
          # specify that auth.example.org will resolve any *.auth.example.org records
           &quot;auth.arpansahu.me. NS auth.arpansahu.me.”,
        ]

        [api]
        # listen IP eg. 127.0.0.1
        IP = &quot;127.0.0.1”. (Changed)

        # listen port, eg. 443 for default HTTPS
        port = &quot;8080&quot; (Changed).         ——— We will use port 8090 because we will also use Jenkins which will be running on 8080 port
        # possible values: &quot;letsencrypt&quot;, &quot;letsencryptstaging&quot;, &quot;cert&quot;, &quot;none&quot;
        tls = &quot;none&quot;   (Changed)

</code></pre>
<pre><code>  * Move the systemd service and reload
</code></pre>
<pre><code class="language-bash">        cat acme-dns.service

        sudo mv \
        acme-dns.service /etc/systemd/system/acme-dns.service

        sudo systemctl daemon-reload
</code></pre>
<pre><code>  * Start and enable acme-dns server
</code></pre>
<pre><code class="language-bash">        sudo systemctl enable acme-dns.service
        sudo systemctl start acme-dns.service
</code></pre>
<pre><code>  * Check acme-dns for possible errors
</code></pre>
<pre><code class="language-bash">        sudo systemctl status acme-dns.service
</code></pre>
<pre><code>  * Use journalctl to debug in case of errors
</code></pre>
<pre><code class="language-bash">         journalctl --unit acme-dns --no-pager --follow
</code></pre>
<pre><code>  * Create A record for your domain
</code></pre>
<pre><code class="language-bash">         auth.arpansahu.me IN A &lt;public-IP&gt;
</code></pre>
<pre><code>  * Create NS record for auth.arpansahu.me pointing to auth.arpansahu.me. This means, that auth.arpansahu.me is
    responsible for any *.auth.arpansahu.me records
</code></pre>
<pre><code class="language-bash">        auth.arpansahu.me IN NS auth.arpansahu.me
</code></pre>
<pre><code>  * Your DNS record will be looking like this
</code></pre>
<pre><code class="language-bash">        A Record    auth    44.199.177.138  Automatic   
        NS Record   auth    auth.arpansahu.me.  Automatic
</code></pre>
<pre><code>  * Test acme-dns server (Split the screen)
</code></pre>
<pre><code class="language-bash">        journalctl -u acme-dns --no-pager --follow
</code></pre>
<pre><code>  * From the local host try to resolve the random DNS record
</code></pre>
<pre><code class="language-bash">        dig api.arpansahu.me
        dig api.auth.arpansahu.me
        dig 7gvhsbvf.auth.arpansahu.me
</code></pre>
<ol>
 <li>
  Install acme-dns-client
 </li>
</ol>
<pre><code class="language-bash">     sudo mkdir /opt/acme-dns-client
     cd !$

     sudo curl -L \
     -o acme-dns-client.tar.gz \
     https://github.com/acme-dns/acme-dns-client/releases/download/v0.2/acme-dns-client_0.2_linux_amd64.tar.gz

     sudo tar -zxf acme-dns-client.tar.gz
     ls
     sudo rm acme-dns-client.tar.gz
     sudo ln -s \
     /opt/acme-dns-client/acme-dns-client /usr/local/bin/acme-dns-client 
</code></pre>
<ol>
 <li>
  Install Certbot
 </li>
</ol>
<pre><code class="language-bash">     cd
     sudo snap install core; sudo snap refresh core
     sudo snap install --classic certbot
     sudo ln -s /snap/bin/certbot /usr/bin/certbot
</code></pre>
<pre><code>Note: you can skip this step if Certbot is already installed

5. Get Letsencrypt Wildcard Certificate
   * Create a new acme-dns account for your domain and set it up
</code></pre>
<pre><code class="language-bash">         sudo acme-dns-client register \
         -d arpansahu.me -s http://localhost:8090
</code></pre>
<pre><code>    The above command is old now we will use the new command
</code></pre>
<pre><code class="language-bash">         sudo acme-dns-client register \
          -d arpansahu.me \
          -allow 0.0.0.0/0 \
          -s http://localhost:8080
</code></pre>
<pre><code>     Note: When we edited acme-dns config file there we mentioned the port 8090 and thats why we are using this port here also

   * Creating Another DNS Entry
</code></pre>
<pre><code class="language-bash">         CNAME Record   _acme-challenge e6ac0f0a-0358-46d6-a9d3-8dd41f44c7ec.auth.arpansahu.me. Automatic
</code></pre>
<pre><code>    Since the last update in  the last step now two more entries should be added
</code></pre>
<pre><code class="language-bash">         CAA Record @   0 issuewild &quot;letsencrypt.org; validationmethods=dns-01; accounturi=https://acme-v02.api.letsencrypt.org/acme/acct/1424899626&quot;  Automatic

         CAA Record @   0 issue &quot;letsencrypt.org; validationmethods=dns-01; accounturi=https://acme-v02.api.letsencrypt.org/acme/acct/1424899626&quot;
         Automatic
</code></pre>
<pre><code>    Same as an entry that needs to be added to complete a time challenge as previously we did.
   * Check whether the entry is added successfully or not
</code></pre>
<pre><code class="language-bash">         dig _acme-challenge.arpansahu.me
</code></pre>
<pre><code>   * Get a wildcard certificate
</code></pre>
<pre><code class="language-bash">         sudo certbot certonly \
         --manual \
         --test-cert \ 
         --preferred-challenges dns \ 
         --manual-auth-hook &#x27;acme-dns-client&#x27; \ 
         -d ‘*.arpansahu.me’ -d arpansahu.me
</code></pre>
<pre><code>    Note: Here we have to mention both the base and wildcard domain names with -d since let&#x27;s encrypt don&#x27;t provide base domain ssl by default in wildcard domain ssl

   * Verifying the certificate
</code></pre>
<pre><code class="language-bash">         sudo openssl x509 -text -noout \
         -in /etc/letsencrypt/live/arpansahu.me/fullchain.pem
</code></pre>
<pre><code>   * Renew certificate (test)
</code></pre>
<pre><code class="language-bash">         sudo certbot renew \
         --manual \ 
         --test-cert \ 
         --dry-run \ 
         --preferred-challenges dns \
         --manual-auth-hook &#x27;acme-dns-client&#x27;       
</code></pre>
<pre><code>   * Renew certificate (actually)
</code></pre>
<pre><code class="language-bash">         sudo certbot renew \
         --manual \
         --preferred-challenges dns \
         --manual-auth-hook &#x27;acme-dns-client&#x27;       
</code></pre>
<pre><code>   * Check the entry is added successfully or not
</code></pre>
<pre><code class="language-bash">         dig _acme-challenge.arpansahu.me
</code></pre>
<pre><code>6. Setup Auto-Renew for Letsencrypt WILDCARD Certificate
   * Setup cronjob
</code></pre>
<pre><code class="language-bash">         sudo crontab -e
</code></pre>
<pre><code>   * Add the following lines to the file
</code></pre>
<pre><code class="language-bash">         0 */12 * * * certbot renew --manual --test-cert --preferred-challenges dns --manual-auth-hook &#x27;acme-dns-client&#x27;
</code></pre>
<p>
 After all these steps your Nginx configuration file located at /etc/nginx/sites-available/arpansahu will be looking similar to this
</p>
<pre><code class="language-bash">server_tokens               off;
access_log                  /var/log/nginx/supersecure.access.log;
error_log                   /var/log/nginx/supersecure.error.log;

server {
    listen         80;
    server_name    great-chat.arpansahu.me;
    # force https-redirects
    if ($scheme = http) {
        return 301 https://$server_name$request_uri;
        }

    location / {
         proxy_pass              http://{ip_of_home_server}:8014;
         proxy_set_header        Host $host;
         proxy_set_header        X-Forwarded-Proto $scheme;

     # WebSocket support
         proxy_http_version 1.1;
         proxy_set_header Upgrade $http_upgrade;
         proxy_set_header Connection &quot;upgrade&quot;;
    }

    listen 443 ssl; # managed by Certbot
    ssl_certificate /etc/letsencrypt/live/arpansahu.me/fullchain.pem; # managed by Certbot
    ssl_certificate_key /etc/letsencrypt/live/arpansahu.me/privkey.pem; # managed by Certbot
    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot
}
</code></pre>
<h3>
 Step 5: CI/CD using Jenkins
</h3>
<h3>
 Installing Jenkins
</h3>
<p>
 Reference: https://www.jenkins.io/doc/book/installing/linux/
</p>
<p>
 Jenkins requires Java to run, yet certain distributions don’t include this by default and some Java versions are incompatible with Jenkins.
</p>
<p>
 There are multiple Java implementations which you can use. OpenJDK is the most popular one at the moment, we will use it in this guide.
</p>
<p>
 Update the Debian apt repositories, install OpenJDK 11, and check the installation with the commands:
</p>
<pre><code class="language-bash">sudo apt update

sudo apt install openjdk-11-jre

java -version
openjdk version &quot;11.0.12&quot; 2021-07-20
OpenJDK Runtime Environment (build 11.0.12+7-post-Debian-2)
OpenJDK 64-Bit Server VM (build 11.0.12+7-post-Debian-2, mixed mode, sharing)
</code></pre>
<p>
 Long Term Support release
</p>
<pre><code class="language-bash">curl -fsSL https://pkg.jenkins.io/debian-stable/jenkins.io.key | sudo tee \
  /usr/share/keyrings/jenkins-keyring.asc &gt; /dev/null
echo deb [signed-by=/usr/share/keyrings/jenkins-keyring.asc] \
  https://pkg.jenkins.io/debian-stable binary/ | sudo tee \
  /etc/apt/sources.list.d/jenkins.list &gt; /dev/null
sudo apt-get update
sudo apt-get install jenkins
</code></pre>
<p>
 Start Jenkins
</p>
<pre><code class="language-bash">sudo systemctl enable jenkins
</code></pre>
<p>
 You can start the Jenkins service with the command:
</p>
<pre><code class="language-bash">sudo systemctl start jenkins
</code></pre>
<p>
 You can check the status of the Jenkins service using the command:
</p>
<pre><code class="language-bash">sudo systemctl status jenkins
</code></pre>
<p>
 Now for serving the Jenkins UI from Nginx add the following lines to the Nginx file located at
 <br/>
 /etc/nginx/sites-available/arpansahu by running the following command
</p>
<pre><code class="language-bash">sudo vi /etc/nginx/sites-available/arpansahu
</code></pre>
<ul>
 <li>
  Add these lines to it.
 </li>
</ul>
<pre><code class="language-bash">    server {
        listen         80;
        server_name    jenkins.arpansahu.me;
        # force https-redirects
        if ($scheme = http) {
            return 301 https://$server_name$request_uri;
            }

        location / {
             proxy_pass              http://{ip_of_home_server}:8080;
             proxy_set_header        Host $host;
             proxy_set_header    X-Forwarded-Proto $scheme;
        }

        listen 443 ssl; # managed by Certbot
        ssl_certificate /etc/letsencrypt/live/arpansahu.me/fullchain.pem; # managed by Certbot
        ssl_certificate_key /etc/letsencrypt/live/arpansahu.me/privkey.pem; # managed by Certbot
        include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot
        ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot
    }
</code></pre>
<p>
 You can add all the server blocks to the same nginx configuration file
 <br/>
 just make sure you place the server block for the base domain at the last
</p>
<ul>
 <li>
  To copy .env from the local server directory while building image
 </li>
</ul>
<p>
 add Jenkins ALL=(ALL) NOPASSWD: ALL
 <br/>
 inside /etc/sudoers file
</p>
<p>
 and then put
</p>
<pre><code class="language-bash">stage(&#x27;Dependencies&#x27;) {
            steps {
                script {
                    sh &quot;sudo cp /root/env/project_name/.env /var/lib/jenkins/workspace/pipeline_project_name&quot;
                }
            }
        }
</code></pre>
<p>
 in Jenkinsfile
</p>
<ul>
 <li>
  Now Create a file named Jenkinsfile at the root of Git Repo and add following lines to file
 </li>
</ul>
<pre><code class="language-bash">pipeline {
    agent { label &#x27;local&#x27; }
    stages {
        stage(&#x27;Initialize&#x27;) {
            steps {
                script {
                    // Log the current workspace path
                    echo &quot;Current workspace path is: ${env.WORKSPACE}&quot;
                }
            }
        }
        stage(&#x27;Checkout&#x27;) {
            steps {
                // Checkout code from SCM
                checkout scm
            }
        }
        stage(&#x27;Dependencies&#x27;) {
            steps {
                script {
                    // Copy .env file to the workspace
                    sh &quot;sudo cp /root/projectenvs/great_chat/.env ${env.WORKSPACE}/&quot;
                }
            }
        }
        stage(&#x27;Production&#x27;) {
            when {
                expression {
                    // Collect all changed files
                    def changes = currentBuild.changeSets.collect { it.items.collect { it.affectedFiles.collect { it.path } } }.flatten()

                    // Define the file(s) to be excluded from triggering a deploy
                    def excludedFiles = [&#x27;Readme.md&#x27;]

                    // Check if the only changed files are in the excluded list
                    def onlyExcludedFilesChanged = changes.every { changedFile -&gt; 
                        excludedFiles.contains(changedFile)
                    }

                    // Proceed with deployment if not only excluded files are changed
                    return !onlyExcludedFilesChanged
                }
            }
            steps {
                script {
                    // Deploy using Docker Compose
                    sh &quot;docker compose up --build --detach&quot;

                    // Set a flag to indicate deployment execution
                    currentBuild.description = &#x27;DEPLOYMENT_EXECUTED&#x27;
                }
            }
        }
    }
    post {
        success {
            script {
                if (currentBuild.description == &#x27;DEPLOYMENT_EXECUTED&#x27;) {
                    // Send success notification email
                    sh &quot;&quot;&quot;curl -s \
                    -X POST \
                    --user $MAIL_JET_API_KEY:$MAIL_JET_API_SECRET \
                    https://api.mailjet.com/v3.1/send \
                    -H &quot;Content-Type:application/json&quot; \
                    -d &#x27;{
                        &quot;Messages&quot;:[
                                {
                                        &quot;From&quot;: {
                                                &quot;Email&quot;: &quot;$MAIL_JET_EMAIL_ADDRESS&quot;,
                                                &quot;Name&quot;: &quot;ArpanSahuOne Jenkins Notification&quot;
                                        },
                                        &quot;To&quot;: [
                                                {
                                                        &quot;Email&quot;: &quot;$MY_EMAIL_ADDRESS&quot;,
                                                        &quot;Name&quot;: &quot;Development Team&quot;
                                                }
                                        ],
                                        &quot;Subject&quot;: &quot;${currentBuild.fullDisplayName} deployed successfully&quot;,
                                        &quot;TextPart&quot;: &quot;Hola Development Team, your project ${currentBuild.fullDisplayName} is now deployed&quot;,
                                        &quot;HTMLPart&quot;: &quot;&lt;h3&gt;Hola Development Team, your project ${currentBuild.fullDisplayName} is now deployed &lt;/h3&gt; &lt;br&gt; &lt;p&gt; Build Url: ${env.BUILD_URL}  &lt;/p&gt;&quot;
                                }
                        ]
                    }&#x27;&quot;&quot;&quot;
                    // Trigger another Jenkins job
                    build job: &#x27;common_readme&#x27;, parameters: [string(name: &#x27;project_git_url&#x27;, value: &#x27;https://github.com/arpansahu/great_chat&#x27;), string(name: &#x27;environment&#x27;, value: &#x27;prod&#x27;)], wait: false
                }
            }
        }
        failure {
            script {
                // Send failure notification email
                sh &quot;&quot;&quot;curl -s \
                -X POST \
                --user $MAIL_JET_API_KEY:$MAIL_JET_API_SECRET \
                https://api.mailjet.com/v3.1/send \
                -H &quot;Content-Type:application/json&quot; \
                -d &#x27;{
                    &quot;Messages&quot;:[
                            {
                                    &quot;From&quot;: {
                                            &quot;Email&quot;: &quot;$MAIL_JET_EMAIL_ADDRESS&quot;,
                                            &quot;Name&quot;: &quot;ArpanSahuOne Jenkins Notification&quot;
                                    },
                                    &quot;To&quot;: [
                                            {
                                                    &quot;Email&quot;: &quot;$MY_EMAIL_ADDRESS&quot;,
                                                    &quot;Name&quot;: &quot;Development Team&quot;
                                            }
                                    ],
                                    &quot;Subject&quot;: &quot;${currentBuild.fullDisplayName} deployment failed&quot;,
                                    &quot;TextPart&quot;: &quot;Hola Development Team, your project ${currentBuild.fullDisplayName} deployment failed&quot;,
                                    &quot;HTMLPart&quot;: &quot;&lt;h3&gt;Hola Development Team, your project ${currentBuild.fullDisplayName} is not deployed, Build Failed &lt;/h3&gt; &lt;br&gt; &lt;p&gt; Build Url: ${env.BUILD_URL}  &lt;/p&gt;&quot;
                            }
                    ]
                }&#x27;&quot;&quot;&quot;
            }
        }
    }
}
</code></pre>
<p>
 Note: agent {label 'local'} is used to specify which node will execute the jenkins job deployment. So local linux server is labelled with 'local' are the project with this label will be executed in local machine node.
</p>
<ul>
 <li>
  Configure a Jenkins project from jenkins ui located at https://jenkins.arpansahu.me
 </li>
</ul>
<p>
 Make sure to use Pipeline project and name it whatever you want I have named it as great_chat
</p>
<p>
 <img alt="Jenkins Pipeline Configuration" src="https://arpansahu@github.com/arpansahu/great_chat/main/Jenkins.png"/>
</p>
<p>
 In this above picture you can see credentials right? you can add your github credentials
 <br/>
 from Manage Jenkins on home Page --> Manage Credentials
</p>
<p>
 and add your GitHub credentials from there
</p>
<ul>
 <li>
  Add a .env file to you project using following command (This step is no more required stage('Dependencies'))
 </li>
</ul>
<pre><code class="language-bash">    sudo vi  /var/lib/jenkins/workspace/great_chat/.env
</code></pre>
<pre><code>Your workspace name may be different.

Add all the env variables as required and mentioned in the Readme File.
</code></pre>
<ul>
 <li>
  <p>
   Add Global Jenkins Variables from Dashboard --> Manage --> Jenkins
   <br/>
   Configure System
  </p>
 </li>
 <li>
  <p>
   MAIL_JET_API_KEY
  </p>
 </li>
 <li>
  MAIL_JET_API_SECRET
 </li>
 <li>
  MAIL_JET_EMAIL_ADDRESS
 </li>
 <li>
  MY_EMAIL_ADDRESS
 </li>
</ul>
<p>
 Now you are good to go.
</p>
<p>
 [SERVICES]
</p>
<h2>
 Documentation
</h2>
<p>
 <a href="https://www.python.org/">
  <img alt="Python" src="https://img.shields.io/badge/Python-3776AB?style=for-the-badge&logo=python&logoColor=white"/>
 </a>
 <br/>
 <a href="https://www.djangoproject.com/">
  <img alt="Django" src="https://img.shields.io/badge/Django-092E20?style=for-the-badge&logo=django&logoColor=white"/>
 </a>
 <br/>
 <a href="https://developer.mozilla.org/en-US/docs/Glossary/HTML5">
  <img alt="HTML5" src="https://img.shields.io/badge/html5-%23E34F26.svg?style=for-the-badge&logo=html5&logoColor=white"/>
 </a>
 <br/>
 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS">
  <img alt="CSS3" src="https://img.shields.io/badge/css3-%231572B6.svg?style=for-the-badge&logo=css3&logoColor=white"/>
 </a>
 <br/>
 <a href="https://getbootstrap.com/">
  <img alt="Bootstrap" src="https://img.shields.io/badge/Bootstrap-563D7C?style=for-the-badge&logo=bootstrap&logoColor=white"/>
 </a>
 <br/>
 <a href="https://www.javascript.com/">
  <img alt="Javascript" src="https://img.shields.io/badge/JavaScript-323330?style=for-the-badge&logo=javascript&logoColor=F7DF1E"/>
 </a>
 <br/>
 <a href="https://redis.io/docs/">
  <img alt="Redis" src="https://img.shields.io/badge/redis-%23DD0031.svg?style=for-the-badge&logo=redis&logoColor=white"/>
 </a>
 <br/>
 <a href="https://www.postgresql.org/docs/">
  <img alt="Postgres" src="https://img.shields.io/badge/postgres-%23316192.svg?style=for-the-badge&logo=postgresql&logoColor=white"/>
 </a>
 <br/>
 <a href="https://heroku.com/">
  <img alt="Heroku" src="https://img.shields.io/badge/-Heroku-430098?style=for-the-badge&logo=heroku&logoColor=white"/>
 </a>
 <br/>
 <a href="https://www.github.com/">
  <img alt="Github" src="https://img.shields.io/badge/GitHub-100000?style=for-the-badge&logo=github&logoColor=white"/>
 </a>
 <br/>
 <a href="https://www.docker.com/">
  <img alt="Docker" src="https://img.shields.io/badge/Docker-2CA5E0?style=for-the-badge&logo=docker&logoColor=white"/>
 </a>
 <br/>
 <a href="https://www.jenkins.io/">
  <img alt="Jenkins" src="https://img.shields.io/badge/Jenkins-D24939?style=for-the-badge&logo=Jenkins&logoColor=white"/>
 </a>
 <br/>
 <a href="https://aws.amazon.com/">
  <img alt="AWS" src="https://img.shields.io/badge/Amazon_AWS-FF9900?style=for-the-badge&logo=amazonaws&logoColor=white"/>
 </a>
 <br/>
 <a href="https://nginx.org/en/">
  <img alt="Nginx" src="https://img.shields.io/badge/Nginx-009639?style=for-the-badge&logo=nginx&logoColor=white"/>
 </a>
 <br/>
 <a href="https://ubuntu.com/">
  <img alt="Ubuntu" src="https://img.shields.io/badge/Ubuntu-E95420?style=for-the-badge&logo=ubuntu&logoColor=white"/>
 </a>
</p>
<h2>
 Environment Variables
</h2>
<p>
 To run this project, you will need to add the following environment variables to your .env file
</p>
<p>
 SECRET_KEY=
</p>
<p>
 DEBUG=
</p>
<p>
 ALLOWED_HOSTS=
</p>
<p>
 MAIL_JET_API_KEY=
</p>
<p>
 MAIL_JET_API_SECRET=
</p>
<p>
 MY_EMAIL_ADDRESS=
</p>
<p>
 AWS_ACCESS_KEY_ID=
</p>
<p>
 AWS_SECRET_ACCESS_KEY=
</p>
<p>
 AWS_STORAGE_BUCKET_NAME=
</p>
<p>
 BUCKET_TYPE=
</p>
<p>
 DOMAIN=
</p>
<p>
 PROTOCOL=
</p>
<p>
 DATABASE_URL=
</p>
<p>
 REDISCLOUD_URL=
</p>
